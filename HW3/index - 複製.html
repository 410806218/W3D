<div id="info">minimal three.js</div>
<script src="https://threejs.org/build/three.min.js"></script>
<script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
<script src="https://threejs.org/examples/js/controls/PointerLockControls.js"></script>
<script src="https://unpkg.com/three@0.129.0/examples/js/loaders/GLTFLoader.js"></script>

<html>
  <style>
    #blocker {
      position: absolute;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.5);
    }

    #instructions {
      width: 100%;
      height: 100%;

      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;

      text-align: center;
      font-size: 14px;
      cursor: pointer;
    }
  </style>
  <div id="blocker">
    <div id="instructions">
      <p style="font-size:36px">
        Click to play
      </p>
      <p>
        Move: WASD<br/>
        Jump: SPACE<br/>
        Look: MOUSE
      </p>
    </div>
  </div>

<body>
<script>

let camera, scene, renderer, controls;

			const objects = [];

			let raycaster;

			let moveForward = false;
			let moveBackward = false;
			let moveLeft = false;
			let moveRight = false;
			let canJump = true;

			let prevTime = performance.now();
			const velocity = new THREE.Vector3();
			const direction = new THREE.Vector3();
			const vertex = new THREE.Vector3();
			const color = new THREE.Color();


init();
animate();

function init() {
  
  scene = new THREE.Scene();

  // renderer = new THREE.WebGLRenderer();
  // renderer.setSize(window.innerWidth, window.innerHeight);
  // renderer.setClearColor(0x888888);
  // document.body.appendChild(renderer.domElement);

  camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
  camera.position.y = 50; // camera at (0,0,500)
  controls = new THREE.PointerLockControls( camera, document.body );
///////////////////////
const blocker = document.getElementById( 'blocker' );
				const instructions = document.getElementById( 'instructions' );

				instructions.addEventListener( 'click', function () {

					controls.lock();

				} );

				controls.addEventListener( 'lock', function () {

					instructions.style.display = 'none';
					blocker.style.display = 'none';

				} );

				controls.addEventListener( 'unlock', function () {

					blocker.style.display = 'block';
					instructions.style.display = '';

				} );

				scene.add( controls.getObject() );

//////////////////////
const onKeyDown = function ( event ) {

switch ( event.code ) {

  case 'ArrowUp':
  case 'KeyW':
    moveForward = true;
    break;

  case 'ArrowLeft':
  case 'KeyA':
    moveLeft = true;
    break;

  case 'ArrowDown':
  case 'KeyS':
    moveBackward = true;
    break;

  case 'ArrowRight':
  case 'KeyD':
    moveRight = true;
    break;

  case 'Space':
    if ( canJump === true ) velocity.y += 350;
    canJump = false;
    break;

}

};
///////////////////////
const onKeyUp = function ( event ) {

switch ( event.code ) {

  case 'ArrowUp':
  case 'KeyW':
    moveForward = false;
    break;

  case 'ArrowLeft':
  case 'KeyA':
    moveLeft = false;
    break;

  case 'ArrowDown':
  case 'KeyS':
    moveBackward = false;
    break;

  case 'ArrowRight':
  case 'KeyD':
    moveRight = false;
    break;

}

};

////////////////////////

document.addEventListener( 'keydown', onKeyDown );
document.addEventListener( 'keyup', onKeyUp );
raycaster = new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3( 0, - 1, 0 ), 0, 10 );
/////////////////////////








  
  const pointLight = new THREE.PointLight( 0xffffff, 1, 100,decay=0);
  pointLight.position.set( 200,200,200 );
  scene.add( pointLight );
  const sphereSize = 50;
  const pointLightHelper = new THREE.PointLightHelper( pointLight, sphereSize );
  scene.add( pointLightHelper );


  const pointLight2 = new THREE.PointLight( 0xffffff, 1, 100,decay=0);
  pointLight2.position.set( 200,-200,-200 );
  scene.add( pointLight2 );
  const pointLightHelper2 = new THREE.PointLightHelper( pointLight2, sphereSize );
  scene.add( pointLightHelper2 );

//    let controls = new THREE.OrbitControls(camera, renderer.domElement);
// //  let controls = new THREE.PointerLockControls( camera, document.body );
//////////////////////////////////////////////////
  var gridXZ = new THREE.GridHelper(100, 100, 'red', 'black');
  scene.add(gridXZ);
//////////////////////////////////////////////

////////////////////////////////////////////////
  var floortexture= new THREE.TextureLoader().load("https://i.imgur.com/PcCtJIV.png");
  floortexture.wrapS = THREE.RepeatWrapping;
  floortexture.wrapT = THREE.RepeatWrapping;
  // var wallTex = new THREE.TextureLoader().load("https://i.imgur.com/F9Dli8Y.jpg");
  // var mat = new THREE.MeshLambertMaterial({
  //   map: woodTex
  // });
/////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////
// let floorGeometry = new THREE.PlaneGeometry( 2000, 2000, 100, 100 );
// 				floorGeometry.rotateX( - Math.PI / 2 );

// 				// vertex displacement

// 				let position = floorGeometry.attributes.position;

// 				for ( let i = 0, l = position.count; i < l; i ++ ) {

// 					vertex.fromBufferAttribute( position, i );

// 					vertex.x += Math.random() * 20 - 10;
// 					vertex.y += Math.random() * 2;
// 					vertex.z += Math.random() * 20 - 10;

// 					position.setXYZ( i, vertex.x, vertex.y, vertex.z );

// 				}

// 				floorGeometry = floorGeometry.toNonIndexed(); // ensure each face has unique vertices

// 				position = floorGeometry.attributes.position;
// 				const colorsFloor = [];

// 				for ( let i = 0, l = position.count; i < l; i ++ ) {

// 					color.setHSL( Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75 );
// 					colorsFloor.push( color.r, color.g, color.b );

// 				}

// 				floorGeometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colorsFloor, 3 ) );

// 				const floorMaterial = new THREE.MeshBasicMaterial( { vertexColors: true } );

// 				const floor = new THREE.Mesh( floorGeometry, floorMaterial );
// 				scene.add( floor );
var floor = new THREE.Mesh (new THREE.PlaneGeometry(50,50,1), new THREE.MeshBasicMaterial({
    map: floortexture,
    side: THREE.DoubleSide,
 
  }));
  floor.rotation.x = -Math.PI/2;
  scene.add (floor);

////////////////////////////////////////////////////////////////////////////////////////////////////////
let officeoutwallPts = [];
officeoutwallPts.push( new THREE.Vector2( 8.5,3 ) );
officeoutwallPts.push( new THREE.Vector2( 8.5,-6 ) );
officeoutwallPts.push( new THREE.Vector2( 11, -11 ) );
officeoutwallPts.push( new THREE.Vector2( 12, -11 ) );
officeoutwallPts.push( new THREE.Vector2( 12, -9 ) ); 
officeoutwallPts.push( new THREE.Vector2( 9.5,-6  ) );
officeoutwallPts.push( new THREE.Vector2( 9.5,3 ) );
officeoutwallPts.push( new THREE.Vector2( 8.5,3 ) );
for ( let i = 0; i < officeoutwallPts.length; i ++ ) officeoutwallPts[ i ].multiplyScalar( 5 );
let officeoutwallShape = new THREE.Shape( officeoutwallPts );
let extrudeSettings = {
	steps: 2,
	depth: 25,
	bevelEnabled: false,
	bevelThickness: 1,
	bevelSize: 1,
	bevelOffset: 0,
	bevelSegments: 1
};
   let geometry = new THREE.ExtrudeGeometry( officeoutwallShape,extrudeSettings );
   let material = new THREE.MeshPhongMaterial( { color: 0xfff9eb ,side: THREE.DoubleSide} );
   var  officeoutwall = new THREE.Mesh( geometry, material ) ;
  
   officeoutwall.rotation.x = Math.PI/2;
   officeoutwall.position.set (-0.5,25,0); 
    scene.add( officeoutwall );
    ////////////////////////////////////////////////////////////////////////////////////////////////////
    let officewallPts = [];
    let x=0,y=0;
    officewallPts.push( new THREE.Vector2( x+12, y-11 ) );
    officewallPts.push( new THREE.Vector2( x+12, y-7 ) );
    officewallPts.push( new THREE.Vector2( x+12.5, y-7 ) );
    officewallPts.push( new THREE.Vector2( x+12.5, y-10.5 ) );
    officewallPts.push( new THREE.Vector2( x+20.5, y-10.5 ) );
    officewallPts.push( new THREE.Vector2( x+20.5, y-8.5 ) );
    officewallPts.push( new THREE.Vector2( x+21, y-8.5 ) );
    officewallPts.push( new THREE.Vector2( x+21, y-10.5 ) );
    officewallPts.push( new THREE.Vector2( x+29, y-10.5 ) );
    //轉彎處
    officewallPts.push( new THREE.Vector2( x+29, y+3 ) );
    officewallPts.push( new THREE.Vector2( x+21, y+3 ) );
    officewallPts.push( new THREE.Vector2( x+21, y-6 ) );
    officewallPts.push( new THREE.Vector2( x+20.5, y-6 ) );
    officewallPts.push( new THREE.Vector2( x+20.5, y+3 ) );
  ////
    officewallPts.push( new THREE.Vector2( x+12.5, y+3 ) );
    officewallPts.push( new THREE.Vector2( x+12.5, y-1 ) );
    officewallPts.push( new THREE.Vector2( x+11.5, y-1 ) );
    officewallPts.push( new THREE.Vector2( x+11.5, y+3.5 ) );
  ///
    officewallPts.push( new THREE.Vector2( x+30, y+3.5 ) );
    officewallPts.push( new THREE.Vector2( x+30, y-11 ) );
    officewallPts.push( new THREE.Vector2( x+12, y-11 ) );
  /////
    for ( let i = 0; i < officewallPts.length; i ++ ) officewallPts[ i ].multiplyScalar( 5 );
    let officewallShape = new THREE.Shape( officewallPts );
    geometry=new THREE.ExtrudeGeometry( officewallShape,extrudeSettings );
    var  officewall = new THREE.Mesh( geometry, material ); 
    officewall.rotation.x = Math.PI/2;
    officewall.position.set (-0.5,25,0); 
    scene.add( officewall );
/////////////////////////////////////////////////////////////////////////////////////////////////////////
//   var texture = new THREE.TextureLoader().load("https://i.imgur.com/1PY6vGw.png");
//   var picture = new THREE.Mesh(new THREE.PlaneGeometry(50, 50), new THREE.MeshBasicMaterial({
//     map: texture,
//     side: THREE.DoubleSide,
//     transparent: true
//   }));
//   scene.add(picture);
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    let GallerywallPts = [];
    
    GallerywallPts.push( new THREE.Vector2( x-30, y-30 ) );
    GallerywallPts.push( new THREE.Vector2( x+30, y-30 ) );
    GallerywallPts.push( new THREE.Vector2( x+30, y+30 ) );
    GallerywallPts.push( new THREE.Vector2( x-30, y+30 ) );
    GallerywallPts.push( new THREE.Vector2( x-30, y-30 ) );
///////////////////////////////////////////////////////////////////////////////////////////////////////////
    let GallerywallholePts = [];
    GallerywallholePts.push( new THREE.Vector2( x-29, y-29 ) );
    GallerywallholePts.push( new THREE.Vector2( x+29, y-29 ) );
    GallerywallholePts.push( new THREE.Vector2( x+29, y+29 ) );
    GallerywallholePts.push( new THREE.Vector2( x-29, y+29 ) );
    GallerywallholePts.push( new THREE.Vector2( x-29, y-29 ) );
///////////////////////////////////////////////////////////////////////////////////////////////////////





////////////////////////////////////////////////////////////////////////////////////////////////////////
    for ( let i = 0; i < GallerywallPts.length; i ++ ) GallerywallPts[ i ].multiplyScalar( 5 );
    let GallerywallShape = new THREE.Shape( GallerywallPts );
    for ( let i = 0; i < GallerywallholePts.length; i ++ ) GallerywallholePts[ i ].multiplyScalar( 5 );
    let GallerywallholeShape = new THREE.Shape( GallerywallholePts );
    GallerywallShape.holes.push(GallerywallholeShape);
    geometry=new THREE.ExtrudeGeometry(GallerywallShape,extrudeSettings );
    var  Gallerywall = new THREE.Mesh( geometry, material ); 
    Gallerywall.rotation.x = Math.PI/2;
    Gallerywall.position.set (-0.5,25,0); 
    scene.add( Gallerywall );
////////////////////////////////////////////////////////////////////////////////////////////////////////////
    let storageroomPts = [];
  
    storageroomPts.push( new THREE.Vector2( x-0.2, y+10 ) );
    storageroomPts.push( new THREE.Vector2( x-0.2, y+30 ) );
    storageroomPts.push( new THREE.Vector2( x+0.2, y+30 ) );
    storageroomPts.push( new THREE.Vector2( x+6.5 ,y+30 ) );
    ////
    storageroomPts.push( new THREE.Vector2( x+6.5 ,y+17.5 ) );
    storageroomPts.push( new THREE.Vector2( x+6 ,y+17.5 ) );
    storageroomPts.push( new THREE.Vector2( x+6 ,y+29.5 ) );
    storageroomPts.push( new THREE.Vector2( x+0.2 ,y+29.5 ) );
    ///

    storageroomPts.push( new THREE.Vector2( x+0.2, y+10.5 ) );
    /////
    storageroomPts.push( new THREE.Vector2( x+6, y+10.5 ) );
    storageroomPts.push( new THREE.Vector2( x+6, y+13 ) );
    storageroomPts.push( new THREE.Vector2( x+6.5 ,y+13 ) );
    storageroomPts.push( new THREE.Vector2( x+6.5 ,y+10 ) );
    storageroomPts.push( new THREE.Vector2( x-0.2 ,y+10 ) );
    for ( let i = 0; i < storageroomPts.length; i ++ ) storageroomPts[ i ].multiplyScalar( 5 );
    let storageroomShape = new THREE.Shape( storageroomPts );
    geometry=new THREE.ExtrudeGeometry(storageroomShape,extrudeSettings );
    var  storageroom = new THREE.Mesh( geometry, material ); 
    storageroom.rotation.x = Math.PI/2;
    storageroom.position.set (0,25,0); 
    scene.add( storageroom );
////////////////////////////////////////////////////////////////////////////////////////////////////////////
let storageroom2Pts = [];
  
  storageroom2Pts.push( new THREE.Vector2( x+9, y+10 ) );
  storageroom2Pts.push( new THREE.Vector2( x+9, y+15 ) );
  storageroom2Pts.push( new THREE.Vector2( x+9.5, y+15 ) );
  storageroom2Pts.push( new THREE.Vector2( x+9.5, y+10.5 ) );
  storageroom2Pts.push( new THREE.Vector2( x+14.5, y+10.5 ) );
  storageroom2Pts.push( new THREE.Vector2( x+14.5, y+19.5 ) );
  storageroom2Pts.push( new THREE.Vector2( x+9.5, y+19.5 ) );
  storageroom2Pts.push( new THREE.Vector2( x+9.5, y+19 ) );
  storageroom2Pts.push( new THREE.Vector2( x+9, y+19 ) );
  storageroom2Pts.push( new THREE.Vector2( x+9, y+20.5 ) );
  storageroom2Pts.push( new THREE.Vector2( x+9.5, y+20.5 ) );
  storageroom2Pts.push( new THREE.Vector2( x+9.5 ,y+20 ) );
  storageroom2Pts.push( new THREE.Vector2( x+14.5, y+20 ) );
  storageroom2Pts.push( new THREE.Vector2( x+14.5, y+29.5 ) );
  storageroom2Pts.push( new THREE.Vector2( x+9.5, y+29.5 ) );
  storageroom2Pts.push( new THREE.Vector2( x+9.5, y+23.5 ) );
  storageroom2Pts.push( new THREE.Vector2( x+9, y+23.5 ) );
  storageroom2Pts.push( new THREE.Vector2( x+9, y+30 ) );
  storageroom2Pts.push( new THREE.Vector2( x+15, y+30 ) );
  storageroom2Pts.push( new THREE.Vector2( x+15, y+10 ) );
  storageroom2Pts.push( new THREE.Vector2( x+9, y+10 ) );

  for ( let i = 0; i < storageroom2Pts.length; i ++ ) storageroom2Pts[ i ].multiplyScalar( 5 );
    let storageroom2Shape = new THREE.Shape( storageroom2Pts );
    geometry=new THREE.ExtrudeGeometry(storageroom2Shape,extrudeSettings );
    var  storageroom2 = new THREE.Mesh( geometry, material ); 
    storageroom2.rotation.x = Math.PI/2;
    storageroom2.position.set (0,25,0); 
    scene.add( storageroom2 );

//////////////////////////////////////////////////////////////////////////////////////////////////
var movewall1 = new THREE.Mesh(new THREE.BoxGeometry(40, 25, 0.5), material);
movewall1.position.set(-125.5,12.5,0);
scene.add (movewall1);
var movewall2 = new THREE.Mesh(new THREE.BoxGeometry(40, 25, 0.5), material);
movewall2.position.set(-70.5,12.5,0);
scene.add (movewall2);
// var movewall3 = new THREE.Mesh(new THREE.BoxGeometry(40, 25, 0.5), material);
// movewall3.position.set(-0.75,12.5,20);
// movewall3.rotation.y=Math.PI/2;
// scene.add (movewall3);
///////////////////////////////////////////////////////////////////////////////////
  var itemTex = new THREE.TextureLoader().load("https://i.imgur.com/14eJxbM.jpg");
  var mat = new THREE.MeshLambertMaterial({
    map: itemTex
  });

var itemplate1 = new THREE.Mesh(new THREE.CylinderGeometry(5,5,13,32), mat);
itemplate1.position.set(0,0,-30);
scene.add (itemplate1);
var itemplate2 = new THREE.Mesh(new THREE.CylinderGeometry(5,5,13,32), mat);
itemplate2.position.set(0,0,-60);
scene.add (itemplate2);
var itemplate3 = new THREE.Mesh(new THREE.CylinderGeometry(5,5,13,32), mat);
itemplate3.position.set(0,0,-90);
scene.add (itemplate3);
var itemplate4 = new THREE.Mesh(new THREE.CylinderGeometry(20,20,13,32), mat);
itemplate4.position.set(-60,0,-60);
scene.add (itemplate4);
////////////////////////////////////////////////
var ceil = new THREE.Mesh(new THREE.BoxGeometry(600, 1, 600), material);
ceil.position.set(-0.75,25,20);
ceil.rotation.y=Math.PI/2;
scene.add (ceil);
////////////////////////////////////////////////////////////////
var loader = new THREE.GLTFLoader();

loader.load( 'a3316pl-1bk_arte_lamp.glb', function ( gltf ) {

	scene.add( gltf.scene );

}, undefined, function ( error ) {

	console.error( error );

} );







///////////////////////////////////////////////////////////////////





        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setClearColor(0x888888);
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				//

				window.addEventListener( 'resize', onWindowResize );
}
function onWindowResize() {

camera.aspect = window.innerWidth / window.innerHeight;
camera.updateProjectionMatrix();

renderer.setSize( window.innerWidth, window.innerHeight );

}
function animate() {

  requestAnimationFrame(animate);
  const time = performance.now();

  if ( controls.isLocked === true ) {

  raycaster.ray.origin.copy( controls.getObject().position );
  raycaster.ray.origin.y -= 10;

  const intersections = raycaster.intersectObjects( objects, false );

  const onObject = intersections.length > 0;

  const delta = ( time - prevTime ) / 1000;

  velocity.x -= velocity.x * 10.0 * delta;
  velocity.z -= velocity.z * 10.0 * delta;

  velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass

  direction.z = Number( moveForward ) - Number( moveBackward );
  direction.x = Number( moveRight ) - Number( moveLeft );
  direction.normalize(); // this ensures consistent movements in all directions

  if ( moveForward || moveBackward ) velocity.z -= direction.z * 400.0 * delta;
  if ( moveLeft || moveRight ) velocity.x -= direction.x * 400.0 * delta;

  if ( onObject === true ) {

    velocity.y = Math.max( 0, velocity.y );
    canJump = true;

  }

  controls.moveRight( - velocity.x * delta );
  controls.moveForward( - velocity.z * delta );

  controls.getObject().position.y += ( velocity.y * delta ); // new behavior

  if ( controls.getObject().position.y < 10 ) {

    velocity.y = 0;
    controls.getObject().position.y = 10;

    canJump = true;

  }
}


prevTime = time;

renderer.render( scene, camera );

}
</script>
</body>
</html>